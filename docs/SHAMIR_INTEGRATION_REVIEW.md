# Shamir Integration Review

Scope reviewed:
- `docs/shamir-implementation.md`
- `backend/src/services/encryption.ts`
- Integration touchpoints: `backend/src/server.ts`, `backend/src/routes/ceremony.ts`, `backend/src/services/shamir.ts`

Date: 2026-02-13

## Executive Summary

Shamir support is partially implemented but **not integrated into actual MEK usage** for encryption/decryption flows. The runtime still depends on environment MEK, and ceremony flows currently do not switch or provide MEK to `EncryptionService` operations. There are also memory-safety and future concurrency hazards in the MEK lifecycle APIs.

---

## 1) How the MEK is currently loaded/used

### Current behavior
- MEK is loaded from `MASTER_ENCRYPTION_KEY` at startup and required unconditionally:
  - `backend/src/server.ts:32`
  - `backend/src/server.ts:43-47`
- `EncryptionService` is instantiated with this env MEK:
  - `backend/src/server.ts:60`
- `EncryptionService` stores MEK in process memory (`this.mek`) and uses it in `encryptDEK` / `decryptDEK`:
  - `backend/src/services/encryption.ts:20`
  - `backend/src/services/encryption.ts:117-121`
  - `backend/src/services/encryption.ts:136-141`

### Shamir-related additions present but unused by runtime
- `enableCeremonyFlow`, `setMEKFromShares`, `clearMEK`, `hasMEK` are defined but not called anywhere outside `encryption.ts`:
  - `backend/src/services/encryption.ts:39-74`
  - No call sites: repo search shows definitions only.

### Critical integration gap
- Ceremony init generates and splits a new MEK (`shamir.generateMEK()`), but this MEK is **not linked** to encryption runtime:
  - `backend/src/routes/ceremony.ts:68-72`
- Therefore, shares generated by ceremony do not drive production encryption/decryption; env MEK still does.

---

## 2) Where MEK must be replaced by ceremony-based flow

### A. Startup and service wiring
- `server.ts` currently hard-fails without env MEK (`backend/src/server.ts:43-47`), conflicting with ceremony model where MEK should not be long-lived in env after initial split.
- Required change:
  - Introduce MEK provider abstraction (e.g., `IMEKProvider`) with modes:
    - `EnvMekProvider` (legacy fallback)
    - `CeremonyMekProvider` (ephemeral, reconstructed per operation/session)
  - Startup logic should:
    - Detect whether completed ceremony exists (`key_ceremonies` table)
    - If yes, **do not require env MEK**
    - If no, allow bootstrap with env MEK (migration path)

### B. EncryptionService key access pattern
- `EncryptionService` currently expects persistent in-memory `this.mek` (`backend/src/services/encryption.ts:20,79-84`).
- Required change:
  - Replace raw internal key state with operation-scoped key acquisition API, e.g.:
    - `withMEK(async (mek) => { ...encrypt/decrypt... })`
  - Ensure DEK wrap/unwrap functions cannot run without explicit scoped key context.

### C. Ceremony recovery endpoint integration
- Recovery route has placeholder integration only:
  - `backend/src/routes/ceremony.ts:296-301`
- Required change:
  - Wire `withReconstructedMEK(...)` to `EncryptionService` operation path for explicit admin recovery workflows.
  - Avoid persisting reconstructed MEK in global singleton state.

### D. Bootstrap/migration phase alignment with spec
- Spec requires fallback behavior before first ceremony (`docs/shamir-implementation.md:104`), but runtime currently forces env MEK always (`backend/src/server.ts:43`).
- Required change:
  - Gate env requirement on ceremony state.
  - Add explicit transition command/workflow: “initial split complete -> env MEK no longer accepted for normal operation.”

---

## 3) Memory safety concerns

### A. `setMEKFromShares` stores external Buffer by reference
- `this.mek = mek` uses caller-provided buffer directly:
  - `backend/src/services/encryption.ts:52-57`
- Risk:
  - Caller can mutate/wipe same buffer unexpectedly.
  - Prior `this.mek` is not wiped before replacement.
- Fix:
  - Copy buffer on set: `this.mek = Buffer.from(mek)`.
  - If existing `this.mek` exists, wipe before overwrite.

### B. `clearMEK`/`enableCeremonyFlow` wipe only Buffer, not other plaintext copies
- Wipes `this.mek` only:
  - `backend/src/services/encryption.ts:42-45`, `63-66`
- Remaining plaintext copies still exist in:
  - `const MEK = process.env.MASTER_ENCRYPTION_KEY || ''` (`backend/src/server.ts:32`)
  - `process.env.MASTER_ENCRYPTION_KEY` itself.
- Fix:
  - Remove long-lived env MEK in ceremony mode.
  - Avoid storing MEK in JS strings longer than needed.

### C. Asynchronous wipe in `shamir.wipeBuffer` is not guaranteed immediate
- Uses `crypto.randomFill(buffer, callback)` without awaiting completion:
  - `backend/src/services/shamir.ts:165-171`
- `withReconstructedMEK` calls this in `finally` but returns immediately (`backend/src/services/shamir.ts:191-193`).
- Risk:
  - Function may return before wipe is complete.
- Fix:
  - Use synchronous wipe (`buffer.fill(0)` or `randomFillSync`) in security-critical teardown.

### D. MEK validation weakness in constructor
- `mekHex.length === 64` checked, but hex character validity not checked:
  - `backend/src/services/encryption.ts:29-33`
- Risk:
  - Invalid hex can produce wrong-length buffer and runtime errors later.
- Fix:
  - Enforce `/^[0-9a-fA-F]{64}$/` plus `Buffer.byteLength(...)` check.

### E. Key logging hazard still present
- `generateMEK()` logs full key:
  - `backend/src/services/encryption.ts:293`
- In Shamir context, this undermines ceremony secrecy if used operationally.
- Fix:
  - Do not log MEK value; print only confirmation/fingerprint.

---

## 4) Race conditions with concurrent MEK access

### A. Global mutable `this.mek` is not concurrency-safe
- `EncryptionService` is singleton-like in server lifecycle; runs and admin actions can overlap.
- If ceremony-based methods are later invoked (`setMEKFromShares`/`clearMEK`) while runs are active, key state can be changed mid-flight.
- Relevant methods:
  - `backend/src/services/encryption.ts:52-57`
  - `backend/src/services/encryption.ts:62-67`
  - `backend/src/services/encryption.ts:79-84`
- Risk:
  - Intermittent `MEK not available` errors or wrong-key operations during concurrent runs.

### B. No locking or reference-counting around MEK lifecycle
- No mutex/semaphore around key set/use/clear boundaries.
- Risk increases with:
  - Scheduled runs + manual runs + recovery/admin endpoints.
- Fix:
  - Introduce key-usage guard:
    - operation-scoped key context with mutex
    - reference-counted lease (`acquireMEK` / `releaseMEK`)
    - forbid `clearMEK` while active leases exist

### C. Ceremony operations are not transactional
- Init/reshare flow has multiple DB writes and loops without transaction:
  - `backend/src/routes/ceremony.ts:61-99`
  - `backend/src/routes/ceremony.ts:179-217`
- Risk:
  - Partial failure leaves guardian/ceremony state inconsistent.
- Fix:
  - Wrap each ceremony in DB transaction and roll back on failure.

---

## Required Changes Before Production Shamir Cutover

1. Wire ceremony state into startup and remove unconditional env MEK requirement after ceremony completion.
2. Replace global persistent `this.mek` usage with operation-scoped key access API.
3. Integrate `/ceremony/recover` with real encryption operations (currently placeholder).
4. Make MEK wipe deterministic/synchronous and eliminate long-lived plaintext copies.
5. Add concurrency controls (mutex/lease) for MEK set/use/clear lifecycle.
6. Add transactional ceremony writes for guardian + ceremony updates.
7. Remove MEK value logging and harden MEK hex validation.

## Bottom Line

The current codebase has **Shamir primitives and ceremony endpoints**, but MEK control for actual encryption remains env-based and globally mutable. Until runtime key acquisition is ceremony-driven and concurrency-safe, Shamir is not functionally enforcing the intended trust boundary.
